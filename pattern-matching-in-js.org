* Abstract
WIP
* Sparkler
- library that inspired proposal
- https://github.com/natefaubion/sparkler
** better default args?
- https://github.com/natefaubion/sparkler#argument-length at bottom
** Variables or hardcoded values
- from lib
#+BEGIN_SRC js
  function expensiveExtraction {
    (MyExtractor(x, y, z), 1) => doThis(),
    (MyExtractor(x, y, z), *) => doThat()
  }
#+END_SRC
* TC 39 proposal
** Link
- https://github.com/tc39/proposal-pattern-matching/blob/latest/CORE.md
** Big picture
- Easy to use after destructuring syntax
- Helps both OO code and functional code
- Operator is a statement, cannot return a value
- depends on ~do~ proposal to return values
** Other
- Cannot do regex directly, need to use ~if~ with a test
- Variables in the ~when~ statement are bound within its body
- Scoping and hoisting is like ~if~
- branches can shadow variables defined outside
- No need for ~else/default~, but can be done with a variable
** Annex B, Performance
- Compiler-side optimizations is the focus
** How is this different from switch?
- destructuring binding
- no fallthrough (allows optimizations and reduces bugs)
** Gotchas
- ~Infinity~, ~undefined~, ~NaN~ are variables and can get reassigned
** Questions
*** TODO Why does this help class code?
*** TODO Does this throw error if no match and no else?
- no else statements
*** So what happens if no match?
*** DONE Does this do some internal optimizations?
    CLOSED: [2018-06-06 Wed 10:34]
- If so, this is a good use case, since doing it manually would be less
  effective
- Yes, optimizations are a big goal of the proposal

*** TODO Could you use this to better handle different func signatures?
- I'm imagining how sometimes a function can be called in these ways
#+BEGIN_SRC js
foo(cb)
foo("arg", cb)
foo("arg", {options}, cb)
#+END_SRC
*** TODO Pattern match for booleans, undefined, etc?
- Perhaps more robust than
#+BEGIN_SRC js
if (!someVariable) return next()
//other code
next()
#+END_SRC
*** TODO How does this work with flow, typescript?
*** TODO Why can't you do this with just destructuring
- optimizations might be one answer?
- undefined errors might be another?
* TODO Fix ecmascript website
- https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
- freezes and blocks until infinity
* do expressions
** Link
- https://github.com/tc39/proposal-do-expressions
** Why?
- Helps functional programming
- Variable is the result of executing some code
- better than ternary assignment for many cases
- Great for jsx templating
** Impressions
- This proposal seems to be lacking relative to pattern matching
- Is that concerning given that pattern matching depends on it?
* In rust
- https://www.youtube.com/watch?v=OkR__wxWrG0
- rust forces else clause
- Js requires more syntax (if, and/or), but can do all the same things
* In elixir
- https://www.youtube.com/watch?v=X6EVLSKqMTY
- Looks mostly like js destructuring
- if you use ~^~ before a var name, it will require it's current value to be
  pattern matched
* In F#
- https://www.youtube.com/watch?v=cnJiITa9Qg0
- compiler forces else clause
- this can be done by extracting into a function
- can match array passed in based on length
* In scala
- https://www.youtube.com/watch?v=ULcpWn23waw
- pattern matching is comparing objects against other objects
- can use it to check types
- better than type casting
- great for strongly typed languages
- can be used for parsing json in a simple clear way
- can be used to add new functions to objects that you don't control
- great for deconstructing, type checking, taking actions based on that
- con do complicated checks (8 steps in email example, with short syntax
